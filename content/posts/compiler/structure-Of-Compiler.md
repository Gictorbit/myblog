---
title: "ساختار کامپایلر | structure of compiler"
date: 2020-02-16T23:16:55+03:30
draft: false
description: "اصول طراحی کامپایلر فصل اول: ساختار کامپایلر (structure of compiler)"
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: inner
author: victor
authorEmoji: 😎
tags: 
- طراحی کامپایلر
- کامپایلر
- ساختار کامپایلر
- structure of compiler
series:
- اصول طراحی کامپایلر
categories:
- طراحی کامپایلر فصل1

image: "images/post-image/compiler/compilerStructure.svg"
meta_image: "images/post-image/compiler/compilerStructure.jpg"
---
همینطور که در قسمت های قبل دیدیم اگر کامپایلر رو به یک جعبه تشبیه کنیم که یک برنامه مبدا (source program) رو به یک برنامه معادل با کارکرد یکسان تبدیل میکند اگر کمی این جعبه رو باز کنیم می بینیم که تمام مراحل کامپایلر از دو قسمت کلی تشکیل شده :
* مراحل تحلیل | analysis
* مراحل ساخت |  synthesis
## مراحل تحلیل (analysis)
مرحله تحلیل برنامه مبدا رو به اجزاء اصلی تقسیم میکند و ساختار گرامری رو در برنامه مبدا اعمال میکند سپس از روی این ساختار کد میانی (intermediate code) معادل رو تولید میکند در این مرحله کد تحلیل می شود و اگر خطا یا اروری وجود داشته باشد پیام های اخطار رو چاپ میکند تا کاربر کد خودش رو اصلاح بکند.
هم چنین در مرحله تحلیل اطلاعاتی درباره برنامه مبدا استخراج میشود و در یک ساختمان داده ای به نام جدول نماد `symbol table` ذخیره می شود که به همراه *کد میانی* تولید شده به مرحله ساخت پاس داده می شوند
## مراحل ساخت (synthesis)
در بخش ساخت، از کد میانی که مرحله قبل تولید شده به همراه اطلاعات جدول نماد که خروجی مراحل تحلیل هستند یک برنامه نهایی (target program) ایجاد میشود.
> به مراحل تحلیل اغلب ` Front End` یا بخش جلویی کامپایلر گفته میشود 
و به مراحل ساخت `Back end` یا عقب کامپایلر می گویند

اگر فرایند کامپایل رو دقیق تر بررسی کنیم می بینیم که این فرایند از فاز های پشت سرهم تشکیل شده و هر فاز کد مبدا رو بررسی میکند و به فاز بعد ارائه میکند برای مثال یک نمونه از تجزیه فاز های کامپایلر رو در شکل زیر می بینید

{{< img src="/images/post-image/compiler/compilerStructure1.png" title="فاز های کامپایلر" caption="Phases of a compiler" alt="فاز های کامپایلر" width="500px" height="500px" position="center" >}}

{{< alert theme="info" dir="rtl" >}}
جدول علائم یا همان  *symbol table* که اطلاعاتی درباره کل برنامه مبدا رو ذخیره میکند توسط همه ی فاز های کامپایل استفاده میشود و همه فاز ها به آن دسترسی دارند
{{< /alert >}}
در کنار جدول علائم یک بخش دیگر به نام کنترل کننده خطا یا  `error handler` هم وجود دارد و فاز ها از آن استفاده می کنند
هم چنین بعضی از کامپایلر ها یک فاز بهینه سازی بین backend و frontend دارند که کد میانی تولید شده رو بهینه سازی میکند و این به backend کمک میکند تا برنامه نهایی بهینه تر باشد
## تحلیل گر لغوی (Lexical Analyser)
به اولین فاز کامپایلر تحلیل لغوی یا اسکن `scanning` میگویند تحلیلگر لغت، تمام کاراکتر های برنامه منبع را می خواند و به صورت رشته های معنادار گروه بندی می کند به این رشته ها `lexeme` می گویند برای هر lexeme تحلیل گر لغت یک توکن `Token` به فرم زیر تولید می کند که این توکن به فاز بعدی یعنی تحلیلگر نحوی تحویل داده خواهد شد.
{{< box >}}
<li>(token name , attribute value)</li>
<li>(مقدار توکن ،  نام توکن)</li>
{{< /box >}}
### انواع توکن | Token
اولین جزء توکن `token name` یک نماد هست که به نوع توکن اشاره می کند و در `analysis syntax` یا تحلیلگر نحوی استفاده می شود. برای توضیح انواع توکن تکه کد زیر رو بررسی میکنیم و توکن های اون رو شناسایی می کنیم
```c
int main(){
    int number = 5;
    if (number>10){
        result=number*60;
    }else{
	printf("Error");
    }
    return 0;
}
```

1- <mark>⠀key word⠀</mark>
تمام دستورات برنامه نویسی که توسط زبان رزرو شده اند جزء این دسته قرار می گیرند
[ `if` , `int` , `else` ,  `printf` , `return`]

2- <mark>⠀Identifier | id⠀</mark>
هر اسمی که توسط برنامه نویس تعریف بشود مثل اسم متغیر ، اسم تابع، اسم کلاس ، نام ماکرو ، اسم یک ساختمان داده ، اسم آرایه و ...
[ `number` , `result` , `main`]

3- <mark>‎‎‏‏‎‎⠀operator⠀</mark>
عملگرها نوع دیگر توکن هستند که شامل عملگر های زبان برنامه نویسی مثل عملگر های ریاضی و انتساب می شود.
[ `*` , `>` , `=` ]

4- <mark>⠀Number⠀</mark>
مقادیر عددی که در برنامه های خود مینویسیم هم نوع دیگر توکن به حساب میاد
[ `5` , `10` , `60` , `0` ]

5- <mark>⠀symbol⠀</mark>
همچنین علائم جز جدا نشدنی برنامه های ما هستن مثل `;` یا پرانتزها و کرلی براکت و.. که در مثال بالا علائم ما مقادیر زیر هستند.
 [ `;` , `{` , `}` , `(` , `)` ]

6-<mark>⠀string⠀</mark>
آخرین نوع توکن رشته ها یا آرایه ای از کاراکترها هستند که معمولا بین دو `"` قرار میگیرند
[ `"Error"`  ]

##### تشخیص Token
برای تشخیص دادن الگوی توکن های موجود در برنامه مبدا، از علم نظریه زبان ها و زبان های منظم در کامپایلر استفاده می شود

جزء دوم توکن `attribute-value` هست که به موجودی برای این توکن در جدول علائم یا symbol table اشاره می کند همچنین برای semantic analysis یا تحلیل معنایی و تولید کد اسمبلی به اطلاعاتی که در symbol table ذخیره شده اند نیاز داریم برای مثال فرض کنید در برنامه مبدا دستور زیر وجود دارد مراحل کامپایل این دستور رو مرور می کنیم 
```
position = initial + rate * 60
```
همینطور که مشخص هست این دستور شامل 7 گروه کاراکتر معنا دار یا 7 `lexeme` هست هر کدام رو به صورت جداگانه بررسی می کنیم
1- متغیر `position` به عنوان یک lexeme توسط کامپایلر شناسایی می شود و از آنجا که یک توکن از نوع identifier هست به توکن ` < 1 , id >` نگاشت میشود. id اشاره به نوع توکن دارد و `1` اشاره به ردیف اول symbol table دارد که اطلاعات مربوط این lexeme مثل اسم متغیر و نوع و... در آن ذخیره شده است.

2- نماد مساوی  `=` هم کاراکتر معنا دار و lexeme دوم در دستور بالا هست و به توکن  `< = >`  نگاشت می شود اما از آنجا که نوع توکن عملگر هست نیازی به attribute  ندارد. همچنین میتوانیم برای عملگر مساوی از نام `assign` استفاده کنیم ولی برای راحتی کار، از خود کاراکتر مساوری به عنوان نام توکن استفاده می کنیم.

3- همینطور `initial` یه عنوان یک lexeme به توکن `< 2 , id >` نگاشت می شود و `2` به موجود دوم symbol table اشاره می کند که اطلاعات متغیر initial رو ذخیره کرده است.

4- عملگر `+` هم یک lexeme بعدی هست و به توکن  `< + >` نگاشت می شود.

5- متغیر `rate` هم به عنوان  lexeme پنجم به توکن `< 3 , id >` نگاشت می شود و `3` به خانه سوم symbol table اشاره می کند که اطلاعات متغیر rate در آن ذخیره شده است.

6- عملگر `*` هم به عنوان یک lexeme به توکن `< * >` map (نگاشت) می شود.

7- عدد `60` آخرین lexeme دستور بالا به توکن `<60>` نگاشت می شود.
 
کاراکتر های خالی که بین lexeme ها فاصله ایجاد کرده اند توسط تحلیلگر لغوی نادیده گرفته می شوند دستور انتساب یا (assignment statement) بالا بعد از تحلیل لغوی به ترتیبی از توکن ها تبدیل می شود
```
<id,1>  < = >  <id,2>  < + >  <id,3>  < * >  <60>
```
در مثال ما نام های = و + و* برای راحتی در توکن ها به عنوان نام های معادل assignment و addition و multiplication استفاده شده اند.
{{< img src="/images/post-image/compiler/compilerStructure2.png" title="کامپایل یک دستور انتساب" caption="translation of an assignment statement" alt="کامپایل دستور انتساب" width="500px" height="500px" position="center" >}}

## تحلیل گر نحوی (Syntax analyser)
فاز دوم کامپایلر syntax analyzer یا پارس `parsing` نام دارد. پارسر `parser` از اولین جزء توکن که توسط تحلیلگر لغوی تولید شده استفاده می کند و یک درخت از ترتیب قرار گیری توکن ها می سازد به این درخت `syntax tree` می گویند. این درخت ساختار گرامری یک دستور رو بر اساس توکن ها نشون میده در واقع در این درخت برگ ها عملوند هستند و راس های آن ها عملگر هستند که اولویت عملگر ها رو هم نشان می دهد  طبق درخت تولید شده در مثال ما اول باید عدد 60 در توکن <3 , id> که همان متغیر rate  هست ضرب شود و نتیجه آن با توکن < 2 , id > که همان initial هست جمع شود و سپس در توکن  < 1 , id > که همان position هست ریخته شود تحلیل گر نحوی چک میکند که ترتیب قرار گیری توکن ها درست باشد به عبارتی دیگر دستور ما طبق الگوی از قبل تعریف شده باشد و سپس درخت سینتکس رو به عنوان خروجی به فاز بعدی یعنی تحلیلگر معنایی یا semantic تحویل می دهد. این کار با استفاده از زبان های مستقل از متن انجام می شود
## تحلیلگر معنایی (Semantic Analysis)
تحلیلگر معنایی از درخت سینتکس که در مرحله قبل تولید شد و اطلاعات symbol table استفاده می کند تا برنامه مبدا رو از نظر معنایی بررسی کند و اطلاعاتی رو در جدول نماد و درخت ذخیره میکند تا در مرحله بعد از آن برای تولید کد میانی استفاده شود
#### type checking
یکی از قسمت های مهم تحلیلگر معنایی` type checking ` هست کامپایلر چک می کند که آیا هر عملگر عملوند مناسب داشته باشد برای مثال هر زبان برنامه نویسی چک میکند که اندیس آرایه از نوع int یا عدد صحیح باشد و اگر عدد اعشاری برای اندیس آرایه استفاده شده باشد خطایی نمایش می دهد گاهی اوقات کامپایلر اجازه میدهد که نوع بعضی متغیر ها به دیگری تبدیل شود مثلا در دستوری که دیدیم فرض کنید  position و initial و rate به عنوان متغیر عدد اعشاری تعریف شده باشند از آنجا که عدد 60 از نوع  int هست `type checker` بعد از دیدن عملگر `*` و بررسی عملوند ها می فهمد که باید یک عدد صحیح (rate) در یک عدد اعشاری ضرب شود در این حالت ممکن است عدد صحیح به عدد اعشاری تبدیل شود در شکل بالا توجه کنید که خروجی تحلیلگر معنایی یک node اضافی برای عملگر `inttofloat` دارد که مستقیما عدد صحیح یا int رو به عدد اعشاری یا float تبدیل می کند
