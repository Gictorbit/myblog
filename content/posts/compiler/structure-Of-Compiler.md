---
title: "ساختار کامپایلر | structure of compiler"
date: 2020-02-16T23:16:55+03:30
draft: false
description: "اصول طراحی کامپایلر فصل اول: ساختار کامپایلر (structure of compiler)"
hideToc: false
enableToc: true
enableTocContent: false
tocPosition: inner
author: victor
authorEmoji: 😎
tags: 
- طراحی کامپایلر
- کامپایلر
- ساختار کامپایلر
- structure of compiler
series:
- اصول طراحی کامپایلر
categories:
- طراحی کامپایلر فصل1

image: "images/post-image/compiler/compilerStructure.svg"
meta_image: "images/post-image/compiler/compilerStructure.jpg"
---
همینطور که در قسمت های قبل دیدیم اگر کامپایلر رو به یک جعبه تشبیه کنیم که یک برنامه مبدا (source program) رو به یک برنامه معادل با کارکرد یکسان تبدیل میکند اگر کمی این جعبه رو باز کنیم می بینیم که تمام مراحل کامپایلر از دو قسمت کلی تشکیل شده :
* مراحل تحلیل | analysis
* مراحل ساخت |  synthesis
## مراحل تحلیل (analysis)
مرحله تحلیل برنامه مبدا رو به اجزاء اصلی تقسیم میکند و ساختار گرامری رو در برنامه مبدا اعمال میکند سپس از روی این ساختار کد میانی (intermediate code) معادل رو تولید میکند در این مرحله کد تحلیل می شود و اگر خطا یا اروری وجود داشته باشد پیام های اخطار رو چاپ میکند تا کاربر کد خودش رو اصلاح بکند.
هم چنین در مرحله تحلیل اطلاعاتی درباره برنامه مبدا استخراج میشود و در یک ساختمان داده ای به نام جدول نماد `symbol table` ذخیره می شود که به همراه *کد میانی* تولید شده به مرحله ساخت پاس داده می شوند
## مراحل ساخت (synthesis)
در بخش ساخت، از کد میانی که مرحله قبل تولید شده به همراه اطلاعات جدول نماد که خروجی مراحل تحلیل هستند یک برنامه نهایی (target program) ایجاد میشود.
> به مراحل تحلیل اغلب ` Front End` یا بخش جلویی کامپایلر گفته میشود 
و به مراحل ساخت `Back end` یا عقب کامپایلر می گویند

اگر فرایند کامپایل رو دقیق تر بررسی کنیم می بینیم که این فرایند از فاز های پشت سرهم تشکیل شده و هر فاز کد مبدا رو بررسی میکند و به فاز بعد ارائه میکند برای مثال یک نمونه از تجزیه فاز های کامپایلر رو در شکل زیر می بینید

{{< img src="/images/post-image/compiler/compilerStructure1.png" title="فاز های کامپایلر" caption="Phases of a compiler" alt="فاز های کامپایلر" width="500px" height="500px" position="center" >}}

{{< alert theme="info" dir="rtl" >}}
جدول علائم یا همان  *symbol table* که اطلاعاتی درباره کل برنامه مبدا رو ذخیره میکند توسط همه ی فاز های کامپایل استفاده میشود و همه فاز ها به آن دسترسی دارند
{{< /alert >}}
در کنار جدول علائم یک بخش دیگر به نام کنترل کننده خطا یا  `error handler` هم وجود دارد و فاز ها از آن استفاده می کنند
هم چنین بعضی از کامپایلر ها یک فاز بهینه سازی بین backend و frontend دارند که کد میانی تولید شده رو بهینه سازی میکند و این به backend کمک میکند تا برنامه نهایی بهینه تر باشد
## تحلیل گر لغوی (Lexical Analysis)
به اولین فاز کامپایلر تحلیل لغوی یا اسکن `scanning` میگویند تحلیلگر لغت، تمام کاراکتر های برنامه منبع را می خواند و به صورت رشته های معنادار گروه بندی می کند به این رشته ها `lexeme` می گویند (رشته ای که برای کامپایلر معنا دارد) برای هر lexeme تحلیل گر لغت یک توکن `Token` به فرم زیر تولید می کند که این توکن به فاز بعدی یعنی تحلیلگر نحوی تحویل داده خواهد شد.
{{< box >}}
<li>(token name , attribute value)</li>
<li>(مقدار توکن ،  نام توکن)</li>
{{< /box >}}
### انواع توکن | Token
اولین جزء توکن `token name` یک نماد هست که به نوع توکن اشاره می کند و در `analysis syntax` یا تحلیلگر نحوی استفاده می شود. برای توضیح انواع توکن تکه کد زیر رو بررسی میکنیم و توکن های اون رو شناسایی می کنیم
```c
int main(){
    int number = 5;
    if (number>10){
        result=number*60;
    }else{
	printf("Error");
    }
    return 0;
}
```

1- <mark>⠀key word⠀</mark>
تمام دستورات برنامه نویسی که توسط زبان رزرو شده اند جزء این دسته قرار می گیرند
[ `if` , `int` , `else` ,  `printf` , `return`]

2- <mark>⠀Identifier | id⠀</mark>
هر اسمی که توسط برنامه نویس تعریف بشود مثل اسم متغیر ، اسم تابع، اسم کلاس ، نام ماکرو ، اسم یک ساختمان داده ، اسم آرایه و ...
[ `number` , `result` , `main`]

3- <mark>‎‎‏‏‎‎⠀operator⠀</mark>
عملگرها نوع دیگر توکن هستند که شامل عملگر های زبان برنامه نویسی مثل عملگر های ریاضی و انتساب می شود.
[ `*` , `>` , `=` ]

4- <mark>⠀Number⠀</mark>
مقادیر عددی که در برنامه های خود مینویسیم هم نوع دیگر توکن به حساب میاد
[ `5` , `10` , `60` , `0` ]

5- <mark>⠀symbol⠀</mark>
همچنین علائم جز جدا نشدنی برنامه های ما هستن مثل `;` یا پرانتزها و کرلی براکت و.. که در مثال بالا علائم ما مقادیر زیر هستند.
 [ `;` , `{` , `}` , `(` , `)` ]

6-<mark>⠀string⠀</mark>
آخرین نوع توکن رشته ها یا آرایه ای از کاراکترها هستند که معمولا بین دو `"` قرار میگیرند
[ `"Error"`  ]

##### تشخیص Token
برای تشخیص دادن الگوی توکن های موجود در برنامه مبدا، از علم نظریه زبان ها و زبان های منظم در کامپایلر استفاده می شود

جزء دوم توکن `attribute-value` هست که به موجودی برای این توکن در جدول علائم یا symbol table اشاره می کند همچنین برای semantic analysis یا تحلیل معنایی و تولید کد اسمبلی به اطلاعاتی که در symbol table ذخیره شده اند نیاز داریم برای مثال فرض کنید در برنامه مبدا دستور زیر وجود دارد مراحل کامپایل این دستور رو مرور می کنیم 
```
position = initial + rate * 60
```
همینطور که مشخص هست این دستور شامل 7 گروه کاراکتر معنا دار برای کامپایلر یا 7 `lexeme` هست هر کدام رو به صورت جداگانه بررسی می کنیم
1- متغیر `position` به عنوان یک lexeme توسط کامپایلر شناسایی می شود و از آنجا که یک توکن از نوع identifier هست به توکن ` < 1 , id >` نگاشت میشود. id اشاره به نوع توکن دارد و `1` اشاره به ردیف اول symbol table دارد که اطلاعات مربوط این lexeme مثل اسم متغیر و نوع و... در آن ذخیره شده است.

2- نماد مساوی  `=` هم کاراکتر معنا دار و lexeme دوم در دستور بالا هست و به توکن  `< = >`  نگاشت می شود اما از آنجا که نوع توکن عملگر هست نیازی به attribute  ندارد. همچنین میتوانیم برای عملگر مساوی از نام `assign` استفاده کنیم ولی برای راحتی کار، از خود کاراکتر مساوری به عنوان نام توکن استفاده می کنیم.

3- همینطور `initial` یه عنوان یک lexeme به توکن `< 2 , id >` نگاشت می شود و `2` به موجود دوم symbol table اشاره می کند که اطلاعات متغیر initial رو ذخیره کرده است.

4- عملگر `+` هم یک lexeme بعدی هست و به توکن  `< + >` نگاشت می شود.

5- متغیر `rate` هم به عنوان  lexeme پنجم به توکن `< 3 , id >` نگاشت می شود و `3` به خانه سوم symbol table اشاره می کند که اطلاعات متغیر rate در آن ذخیره شده است.

6- عملگر `*` هم به عنوان یک lexeme به توکن `< * >` map (نگاشت) می شود.

7- عدد `60` آخرین lexeme دستور بالا به توکن `<60>` نگاشت می شود.
 
کاراکتر های خالی که بین lexeme ها فاصله ایجاد کرده اند توسط تحلیلگر لغوی نادیده گرفته می شوند دستور انتساب یا (assignment statement) بالا بعد از تحلیل لغوی به ترتیبی از توکن ها تبدیل می شود
```
<id,1>  < = >  <id,2>  < + >  <id,3>  < * >  <60>
```
در مثال ما نام های = و + و* برای راحتی در توکن ها به عنوان نام های معادل assignment و addition و multiplication استفاده شده اند.
{{< img src="/images/post-image/compiler/compilerStructure2.png" title="کامپایل یک دستور انتساب" caption="translation of an assignment statement" alt="کامپایل دستور انتساب" width="500px" height="500px" position="center" >}}


